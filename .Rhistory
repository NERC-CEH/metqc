#xy = T adds the x and y coordinates as columns
dt <- as.data.frame(final_raster,xy =T) %>%
#remove NAs
filter(!is.na(layer)) %>%
#convert to data.table
as.data.table()
#Set plotting breaks
#check out the max and min
max(csv$layer)
min(csv$layer)
#assign breaks as you think appropriate, making sure the first one is less than the min and last one greater than the max
brks<-c(-1,1,2.5,5,10,15,20)
#create plot labels (bigger than, between x-y) with the breaks
labels<-c(paste0("< ",brks[2]),paste0(">",brks[2:(length(brks)-2)]," - ",brks[3:(length(brks)-1)]),paste0("> ",brks[(length(brks)-1)]))
#this is a bit of data.table code, don't worry too much about this if you haven't used data.table before
dt[,cat:=cut(layer,breaks=brks,labels=labels)]
#assigning colours
cols <- c("#440154FF","#414487FF","#2A788EFF","#22A884FF","#7AD151FF","#FDE725FF")
#Creating the plot----
ggplot() +
#geom_tile for categorical data with an x and y
geom_tile(data=dt,aes(x=x,y=y,fill=cat)) +
#manual way to set labels, automated with the above objects
scale_fill_manual(name = "Wet deposition in [units]",
breaks=labels,
labels=labels,
values=cols,
drop = FALSE)+
#Overall plot customisation, no x and y labels needed for a map, overall title can be edited (and autofilled for example by region)
labs(title = "Example plot, INMS data for whole region",
x= "",
y = "") +
#just removing background stripes that aren't needed
theme(panel.grid.major = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
strip.background = element_blank())+
#adding the region outlines
geom_sf(data=shp,colour = alpha("red",0.4), fill =NA,size =0.25)+
#coord_sf needed for as you will be aware.
coord_sf()
# # Draw the contours
# grid.polygon(polyxs, polyys, id.lengths = eachlevel,
#              name = "contours", default.units = "native",
#              gp = gpar(fill = fillColours,
#                        col = adjustcolor(fillColours,
#                                          1, 0.9, 0.9, 0.9)))
#
# shapefile <- readShapePoly(paste0(dir,"EE-demo_INMS.shp"))
# allcoordinates_lapply = function(x) {
#   polys = x@polygons
#   return(do.call("rbind", lapply(polys, function(pp) {
#     do.call("rbind", lapply(pp@Polygons, coordinates))
#   })))
# }
# q = allcoordinates_lapply(shapefile)
#
#
# grid.text("testing", gp=gpar(cex=3, col="grey"))
# #cg <- grob()
# cg <- circleGrob(r=.25, gp=gpar(col="grey"))
# grid.draw(cg)
# pushViewport(viewport(clip=cg))
# grid.text("testing", gp=gpar(cex=3))
#Cropping and plotting rasters using shapefiles----
#Example using inms data
#tz 20/11/20
#Packages -----
library(ncdf4) # package for netcdf manipulation
library(raster) # package for raster manipulation
library(rgdal) # package for geospatial analysis
library(sf)
library(dplyr)
library(ggplot2)
library(fasterize)
library(data.table)
library(ggtern)
#Directory----
dir <- "C:/Users/thowag/Documents/INMS/"
#Loading in raster----
r_wdep <- raster(paste0(dir, "1_WDEP_PREC.tif"))
#check the resolution of the inms raster
res(r_wdep) #bit of an odd res, to be expected in degrees, but we'll run with it
#Loading shapefile----
shp <- st_read(paste0(dir,"EE-demo_INMS.shp"))
#Creating an extra "ID" column, will be clear why later
shp$ID <- seq_along(shp$Name)
#Comparing the crs, both wgs84
st_crs(shp)
crs(r_wdep)
#Rasterising the shapefile----
#Obtaining the extent of the shapefile
rast_ext <-extent(shp)
#obtaining the resolution of the inms raster
rast_rest <- res(r_wdep)
#Setting up a reference raster----
#Here we create an empty raster with the extent of the shapefile and resolution of the raster
r<-raster(extent(rast_ext),res=rast_rest)
#the raster has no values, so here we populate it with values
r[]<-1:ncell(r)
#flip it so it goes from low - high (don't actually remember why I always do this haha - there must be a good reason for it....)
r <-flip(r,2)
#Making the region into a matching raster,
#this way deposition can be cropped and scaled by region/country,
#and if you wanted country totals could be obtained.
#This is why we created the ID field, so every region/country has a unique ID
region <- fasterize(shp,r,field="ID")
#the shapefile is quite small, so it looks a bit silly. With larger regions (or higher resolution inms data), it will look better
plot(region)
#Preparing the raster for cropping----
#crop the deposition raster to the region
r_wdep <- crop(r_wdep, region)
#extents are v slightly different
extent(r_wdep) <- extent(region)
#stacking to check they line up
#stacking rasters is always a good way to check, if the extents or something else is different it won't let you
s1 <- stack(r_wdep,region)
#duplicating the raster for the second example
foreach_region <- region
#Example 1: cutting the raster based on the whole shapefile----
#Set all values in the region raster to 1
region[region] <- 1
#multiply r_wdep raster by region, the wdep value * 1 will only return the cells in the region raster
final_raster <- r_wdep*region
plot(final_raster)
plot(st_geometry(shp), add =T)
#Example 2: Cutting the raster for each region in the shapefile----
#empty lists
raster_list <- list()
total_list <- list()
#start a loop, for each country in country ID, so:
for(i in shp$ID){
#set all the corresponding values in the region raster that are not the given ID to 0
r1 <- calc(foreach_region, fun = function(x){x[x!=i]<-0; return(x)})
#and now set all values left in the raster (only the selected region) to 1
r1[r1] <- 1
#as above, multiply
x <- r_wdep*r1
#add to the list
raster_list[[i]] <- x
#in this case you can also obtain totals by country, always nice to check it adds up to the original total
total <- cellStats(x, "sum")
df <- as.data.frame(total)
#make sure to add a column that identifies which region's value you are dealing with
df$ID <- i
total_list[[i]] <- df
}
#turn your list of individual countries into a stack
s <- stack(raster_list)
#plot to inspect, should become a nice mosaic without any overlap
plot(s)
#plotting individual regions---
#just an example, but you could automate this process as above if you wanted
plot(s$layer.1)
shp1 <- shp %>%
filter(ID == 1)
plot(st_geometry(shp1), add =T)
#checking totals----
df <- bind_rows(total_list)
#the sum of individual regions
sum(df$total)
#sum of our raster, not broken down by region
cellStats(final_raster, "sum")
#the add up
#If you go straight to example 2, without making an overall raster first, you can obtain it with stackapply
overall_raster <- stackApply(s,indices =1, fun = "sum")
plot(overall_raster)
cellStats(overall_raster,"sum")
#Mapping rasters in ggplot----
#using the final raster here, but you could plot this by region
#for(i in shp$ID){
#raster_to_be_converted <- s[[i]]
# region_to_be_plotted <- shp %>%
#   filter(ID == i)
#continue as below, replace geom_sf(date =region_to_be_plotted) and you can use bquote(i) to insert the region's name into the plot title
#}
#Turning the raster into a dataframe, ggplot does not support rasters
#xy = T adds the x and y coordinates as columns
dt <- as.data.frame(final_raster,xy =T) %>%
#remove NAs
filter(!is.na(layer)) %>%
#convert to data.table
as.data.table()
#Set plotting breaks
#check out the max and min
max(dt$layer)
min(dt$layer)
#assign breaks as you think appropriate, making sure the first one is less than the min and last one greater than the max
brks<-c(-1,1,2.5,5,10,15,20)
#create plot labels (bigger than, between x-y) with the breaks
labels<-c(paste0("< ",brks[2]),paste0(">",brks[2:(length(brks)-2)]," - ",brks[3:(length(brks)-1)]),paste0("> ",brks[(length(brks)-1)]))
#this is a bit of data.table code, don't worry too much about this if you haven't used data.table before
dt[,cat:=cut(layer,breaks=brks,labels=labels)]
#assigning colours
cols <- c("#440154FF","#414487FF","#2A788EFF","#22A884FF","#7AD151FF","#FDE725FF")
#Creating the plot----
ggplot() +
#geom_tile for categorical data with an x and y
geom_tile(data=dt,aes(x=x,y=y,fill=cat)) +
#manual way to set labels, automated with the above objects
scale_fill_manual(name = "Wet deposition in [units]",
breaks=labels,
labels=labels,
values=cols,
drop = FALSE)+
#Overall plot customisation, no x and y labels needed for a map, overall title can be edited (and autofilled for example by region)
labs(title = "Example plot, INMS data for whole region",
x= "",
y = "") +
#just removing background stripes that aren't needed
theme(panel.grid.major = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
strip.background = element_blank())+
#adding the region outlines
geom_sf(data=shp,colour = alpha("red",0.4), fill =NA,size =0.25)+
#coord_sf needed for as you will be aware.
coord_sf()
# # Draw the contours
# grid.polygon(polyxs, polyys, id.lengths = eachlevel,
#              name = "contours", default.units = "native",
#              gp = gpar(fill = fillColours,
#                        col = adjustcolor(fillColours,
#                                          1, 0.9, 0.9, 0.9)))
#
# shapefile <- readShapePoly(paste0(dir,"EE-demo_INMS.shp"))
# allcoordinates_lapply = function(x) {
#   polys = x@polygons
#   return(do.call("rbind", lapply(polys, function(pp) {
#     do.call("rbind", lapply(pp@Polygons, coordinates))
#   })))
# }
# q = allcoordinates_lapply(shapefile)
#
#
# grid.text("testing", gp=gpar(cex=3, col="grey"))
# #cg <- grob()
# cg <- circleGrob(r=.25, gp=gpar(col="grey"))
# grid.draw(cg)
# pushViewport(viewport(clip=cg))
# grid.text("testing", gp=gpar(cex=3))
#Cropping and plotting rasters using shapefiles----
#Example using inms data
#tz 20/11/20
#Packages -----
library(ncdf4) # package for netcdf manipulation
library(raster) # package for raster manipulation
library(rgdal) # package for geospatial analysis
library(sf)
library(dplyr)
library(ggplot2)
library(fasterize)
library(data.table)
#Directory----
dir <- "C:/Users/thowag/Documents/INMS/"
#Loading in raster----
r_wdep <- raster(paste0(dir, "1_WDEP_PREC.tif"))
#check the resolution of the inms raster
res(r_wdep) #bit of an odd res, to be expected in degrees, but we'll run with it
#Loading shapefile----
shp <- st_read(paste0(dir,"EE-demo_INMS.shp"))
#Creating an extra "ID" column, will be clear why later
shp$ID <- seq_along(shp$Name)
#Comparing the crs, both wgs84
st_crs(shp)
crs(r_wdep)
#Rasterising the shapefile----
#Obtaining the extent of the shapefile
rast_ext <-extent(shp)
#obtaining the resolution of the inms raster
rast_rest <- res(r_wdep)
#Setting up a reference raster----
#Here we create an empty raster with the extent of the shapefile and resolution of the raster
r<-raster(extent(rast_ext),res=rast_rest)
#the raster has no values, so here we populate it with values
r[]<-1:ncell(r)
#flip it so it goes from low - high (don't actually remember why I always do this haha - there must be a good reason for it....)
r <-flip(r,2)
#Making the region into a matching raster,
#this way deposition can be cropped and scaled by region/country,
#and if you wanted country totals could be obtained.
#This is why we created the ID field, so every region/country has a unique ID
region <- fasterize(shp,r,field="ID")
#the shapefile is quite small, so it looks a bit silly. With larger regions (or higher resolution inms data), it will look better
plot(region)
#Preparing the raster for cropping----
#crop the deposition raster to the region
r_wdep <- crop(r_wdep, region)
#extents are v slightly different
extent(r_wdep) <- extent(region)
#stacking to check they line up
#stacking rasters is always a good way to check, if the extents or something else is different it won't let you
s1 <- stack(r_wdep,region)
#duplicating the raster for the second example
foreach_region <- region
#Example 1: cutting the raster based on the whole shapefile----
#Set all values in the region raster to 1
region[region] <- 1
#multiply r_wdep raster by region, the wdep value * 1 will only return the cells in the region raster
final_raster <- r_wdep*region
plot(final_raster)
plot(st_geometry(shp), add =T)
#Example 2: Cutting the raster for each region in the shapefile----
#empty lists
raster_list <- list()
total_list <- list()
#start a loop, for each country in country ID, so:
for(i in shp$ID){
#set all the corresponding values in the region raster that are not the given ID to 0
r1 <- calc(foreach_region, fun = function(x){x[x!=i]<-0; return(x)})
#and now set all values left in the raster (only the selected region) to 1
r1[r1] <- 1
#as above, multiply
x <- r_wdep*r1
#add to the list
raster_list[[i]] <- x
#in this case you can also obtain totals by country, always nice to check it adds up to the original total
total <- cellStats(x, "sum")
df <- as.data.frame(total)
#make sure to add a column that identifies which region's value you are dealing with
df$ID <- i
total_list[[i]] <- df
}
#turn your list of individual countries into a stack
s <- stack(raster_list)
#plot to inspect, should become a nice mosaic without any overlap
plot(s)
#plotting individual regions---
#just an example, but you could automate this process as above if you wanted
plot(s$layer.1)
shp1 <- shp %>%
filter(ID == 1)
plot(st_geometry(shp1), add =T)
#checking totals----
df <- bind_rows(total_list)
#the sum of individual regions
sum(df$total)
#sum of our raster, not broken down by region
cellStats(final_raster, "sum")
#the add up
#If you go straight to example 2, without making an overall raster first, you can obtain it with stackapply
overall_raster <- stackApply(s,indices =1, fun = "sum")
plot(overall_raster)
cellStats(overall_raster,"sum")
#Mapping rasters in ggplot----
#using the final raster here, but you could plot this by region
#for(i in shp$ID){
#raster_to_be_converted <- s[[i]]
# region_to_be_plotted <- shp %>%
#   filter(ID == i)
#continue as below, replace geom_sf(date =region_to_be_plotted) and you can use bquote(i) to insert the region's name into the plot title
#}
#Turning the raster into a dataframe, ggplot does not support rasters
#xy = T adds the x and y coordinates as columns
dt <- as.data.frame(final_raster,xy =T) %>%
#remove NAs
filter(!is.na(layer)) %>%
#convert to data.table
as.data.table()
#Set plotting breaks
#check out the max and min
max(dt$layer)
min(dt$layer)
#assign breaks as you think appropriate, making sure the first one is less than the min and last one greater than the max
brks<-c(-1,1,2.5,5,10,15,20)
#create plot labels (bigger than, between x-y) with the breaks
labels<-c(paste0("< ",brks[2]),paste0(">",brks[2:(length(brks)-2)]," - ",brks[3:(length(brks)-1)]),paste0("> ",brks[(length(brks)-1)]))
#this is a bit of data.table code, don't worry too much about this if you haven't used data.table before
dt[,cat:=cut(layer,breaks=brks,labels=labels)]
#assigning colours
cols <- c("#440154FF","#414487FF","#2A788EFF","#22A884FF","#7AD151FF","#FDE725FF")
#Creating the plot----
ggplot() +
#geom_tile for categorical data with an x and y
geom_tile(data=dt,aes(x=x,y=y,fill=cat)) +
#manual way to set labels, automated with the above objects
scale_fill_manual(name = "Wet deposition in [units]",
breaks=labels,
labels=labels,
values=cols,
drop = FALSE)+
#Overall plot customisation, no x and y labels needed for a map, overall title can be edited (and autofilled for example by region)
labs(title = "Example plot, INMS data for whole region",
x= "",
y = "") +
#just removing background stripes that aren't needed
theme(panel.grid.major = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
strip.background = element_blank())+
#adding the region outlines
geom_sf(data=shp,colour = alpha("red",0.4), fill =NA,size =0.25)+
#coord_sf needed for as you will be aware.
coord_sf()
# # Draw the contours
# grid.polygon(polyxs, polyys, id.lengths = eachlevel,
#              name = "contours", default.units = "native",
#              gp = gpar(fill = fillColours,
#                        col = adjustcolor(fillColours,
#                                          1, 0.9, 0.9, 0.9)))
#
# shapefile <- readShapePoly(paste0(dir,"EE-demo_INMS.shp"))
# allcoordinates_lapply = function(x) {
#   polys = x@polygons
#   return(do.call("rbind", lapply(polys, function(pp) {
#     do.call("rbind", lapply(pp@Polygons, coordinates))
#   })))
# }
# q = allcoordinates_lapply(shapefile)
#
#
# grid.text("testing", gp=gpar(cex=3, col="grey"))
# #cg <- grob()
# cg <- circleGrob(r=.25, gp=gpar(col="grey"))
# grid.draw(cg)
# pushViewport(viewport(clip=cg))
# grid.text("testing", gp=gpar(cex=3))
#Creating the plot----
ggplot() +
#geom_tile for categorical data with an x and y
geom_tile(data=dt,aes(x=x,y=y,fill=cat)) +
#manual way to set labels, automated with the above objects
scale_fill_manual(name = "Wet deposition in [units]",
breaks=labels,
labels=labels,
values=cols,
drop = FALSE)+
#Overall plot customisation, no x and y labels needed for a map, overall title can be edited (and autofilled for example by region)
labs(title = "Example plot, INMS data for whole region",
x= "",
y = "") +
#just removing background stripes that aren't needed
theme(panel.grid.major = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
strip.background = element_blank())
a
#Creating the plot----
ggplot() +
#geom_tile for categorical data with an x and y
geom_tile(data=dt,aes(x=x,y=y,fill=cat)) +
#manual way to set labels, automated with the above objects
scale_fill_manual(name = "Wet deposition in [units]",
breaks=labels,
labels=labels,
values=cols,
drop = FALSE)+
#Overall plot customisation, no x and y labels needed for a map, overall title can be edited (and autofilled for example by region)
labs(title = "Example plot, INMS data for whole region",
x= "",
y = "") +
#just removing background stripes that aren't needed
theme(panel.grid.major = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
strip.background = element_blank())+
#adding the region outlines
geom_sf(data=shp,colour = alpha("red",0.4), fill =NA,size =0.25)+
#Creating the plot----
ggplot() +
#geom_tile for categorical data with an x and y
geom_tile(data=dt,aes(x=x,y=y,fill=cat)) +
#manual way to set labels, automated with the above objects
scale_fill_manual(name = "Wet deposition in [units]",
breaks=labels,
labels=labels,
values=cols,
drop = FALSE)+
#Overall plot customisation, no x and y labels needed for a map, overall title can be edited (and autofilled for example by region)
labs(title = "Example plot, INMS data for whole region",
x= "",
y = "") +
#just removing background stripes that aren't needed
theme(panel.grid.major = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
strip.background = element_blank())+
#adding the region outlines
geom_sf(data=shp,colour = alpha("red",0.4), fill =NA,size =0.25)
#Creating the plot----
ggplot() +
#geom_tile for categorical data with an x and y
geom_tile(data=dt,aes(x=x,y=y,fill=cat)) +
#manual way to set labels, automated with the above objects
scale_fill_manual(name = "Wet deposition in [units]",
breaks=labels,
labels=labels,
values=cols,
drop = FALSE)+
#Overall plot customisation, no x and y labels needed for a map, overall title can be edited (and autofilled for example by region)
labs(title = "Example plot, INMS data for whole region",
x= "",
y = "") +
#just removing background stripes that aren't needed
theme(panel.grid.major = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
strip.background = element_blank())+
#adding the region outlines
geom_sf(data=shp,colour = alpha("red",0.4), fill =NA,size =0.25)+
# #coord_sf needed for as you will be aware.
coord_sf()
shiny::runApp()
install.packages("ROracle")
install.packages("Rtools")
