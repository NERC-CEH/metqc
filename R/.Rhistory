# Inspect the files----
plot(r_da)
# Reprojecting rasters----
r_da_osgb <- projectRaster(r_da, r)
plot(r_da_osgb)
# Great, still includes ROI though, I'll just mask with r_dauth
r_da_osgb <- mask(r_da_osgb,r_dauth)
plot(r_da_osgb)
# Repeat for the other file
r_aw_osgb <- projectRaster(r_aw,r)
r_aw_osgb <- mask(r_aw_osgb,r_dauth)
# Checking numbers----
cellStats(r_da_osgb, sum)
cellStats(r_aw_osgb, sum)
# interesting - they are slightly different even though we are in the same "census" area
# Starting to wonder if GB is mislabelled as UK
# Let's get individual totals for each DA, for both rasters
l_total <- list()
for(i in unique(r_dauth)){
#assign loop raster as not to overwrite original
r_loop <- r_dauth
r_loop[r_loop!=i] <- NA
r_loop[r_loop == i] <-1
# first for da method
r_da_loop <- r_loop*r_da_osgb
df_da_total <- cellStats(r_da_loop,sum)
df_dauth <- as.data.frame(df_da_total)
# repeat for aw method
r_aw_loop<- r_loop*r_aw_osgb
df_aw_total <- cellStats(r_aw_loop,sum)
df_dauth$df_aw_total <- df_aw_total
df_dauth$dauth_number <- i
l_total[[i]] <- df_dauth
}
# Get list together into df
df_dauth_comparison <- bind_rows(l_total)
# Link to dauth names
dauth_names <- data.frame(dauth_number = c(1,2,3,5),
dauth_name = c("Wales","England","Scotland","Northern Ireland"))
df_dauth_comparison <- left_join(df_dauth_comparison, dauth_names)
# It's just slightly different numbers for each method - no mislabelling.
kable(df_dauth_comparison)
# Turning rasters into dataframe----
df_glw <- as.data.frame(r_da_osgb,xy=T)
# And into datatable
dt_glw <- as.data.table(df_glw)
# Repeat for aw method
df_aw <- as.data.frame(r_aw_osgb,xy=T)
dt_aw <- as.data.table(df_aw)
# And combine
dt_glw <- bind_rows(dt_glw,dt_aw)
colnames(dt_glw) <- c("x","y","da_method","aw_method")
# Reorganise to get  categorical columns
dt_glw <- pivot_longer(dt_glw, cols = 3:4,names_to = "spatial_method",values_to = "chicken_number") %>%
as.data.frame() %>%
as.data.table()
# Clean up the datatable
colnames(dt_glw) <- c("eastings","northings","spatial_method","chicken_number")
# Instead of removing NAs, we'll turn them to 0
# At some point we'll compare with UK totals and we want to represent differences
#dt_glw[is.na(dt_glw)] <- 0
# Unfortunately keeping them does remove the plots so:
# Try with removal of NAs
dt_glw <- dt_glw[complete.cases(dt_glw[, 'chicken_number'])]
# Plotting the raster-----
# Set plotting breaks
breaks <- c(0,1,100,1000,10000,100000,1616050)
# Categorise breaks with the cut() function and feeding breaks
dt_glw$cat <- cut(dt_glw$chicken_number,breaks, dig.lab=10, include.lowest = TRUE)
are_there_nas <- dt_glw %>%
filter(is.na(cat))
# Set factor levels and turn them into a factor for plotting
levels(dt_glw$cat)<-as.factor(gsub(","," - ",gsub("\\]|\\(|\\[","",levels(dt_glw$cat))))
dt_glw$cat <- factor(dt_glw$cat, levels=rev(levels(dt_glw$cat)))
# Plot theme
GGPLOT.THEME.GRIDMAP<-function(text_size){
theme(panel.grid.major = element_line(colour=NA),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.ticks.x = element_blank(),
axis.ticks.y = element_blank(),
plot.title=element_text(size=36,family = "sans"),
strip.background = element_rect(fill="white"),
axis.line.x = element_blank(),
axis.line.y = element_blank(),
axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
legend.key.height=unit(1.2,"cm"),
legend.key.width=unit(0.8,"cm"),
strip.text = element_text(colour="black", size = text_size*1.4, face="bold",family = "sans"),
legend.title = element_text(colour="black", size = text_size*1.4, face="bold",family = "sans"),
legend.text = element_text(colour="black", size = text_size*1.2,family = "sans"))}
ggplot()+
geom_tile(data=dt_glw, aes(x=eastings,y=northings,fill=cat))+
facet_wrap(~spatial_method)+
scale_fill_viridis_d(name = bquote("number of chickens"), na.translate=T,
option="A", na.value="grey")+
GGPLOT.THEME.GRIDMAP(text_size=12)
dir_dukems <- "C:\\Users\\thowag\\Documents\\dukems_nh3\\"
list.files(dir_dukems)
nc_dukems <- "C:\\Users\\thowag\\Documents\\dukems_nh3\\wrfout_d03_20180101-20190101_RAINNC_dy.nc"
nc_open(nc_dukems)
library(ncdf4)
library(raster)
library(lubridate)
library(ggplot2)
library(sf)
nc_open(nc_dukems)
names(nc_dukems$dim)
nc_dukems <- nc_open(nc_dukems)
names(nc_dukems$dim)
# Time variable check
ncatt_get(nc_dukems, varid = "time")
# Time variable check
ncatt_get(nc_dukems, varid = "XTIME")
# Listing variables
names(nc$var)
# Listing variables
names(nc_dukems$var)
# Extracting rain
ncatt_get(nc_dukems, "RAINNC")
# Files and directories----
nc_dukems_filename <- "C:\\Users\\thowag\\Documents\\dukems_nh3\\wrfout_d03_20180101-20190101_RAINNC_dy.nc"
# Extracting single raster----
r_rain <- raster(nc_dukems_filename, varname = "RAINNC")
r_rain
plot(r_rain)
# Read in UK raster----
r_dauth <- raster("N:\\Useful_datasets\\dauth.asc")
# Take out the Isle of Man, which is labelled 4 in this raster
r_dauth[r_dauth == 4] <- NA
# Turn into UK reference raster
r <- setValues(r_dauth, 1:ncell(r_dauth))
# Need to set to osgb from https://spatialreference.org/ref/epsg/27700/proj4/
osgb<-"+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs "
# Set crs
crs(r) <- osgb
crs(r_rain) <- osgb
# Masking WRF data to UK extent
r_test <- masK(r_rain, r)
library(raster)
# Masking WRF data to UK extent
r_test <- mask(r_rain, r)
# Masking WRF data to UK extent
r_test <- projectRaster(r_rain, r)
plot(r_test)
plot(r_rain)
# Masking WRF data to UK extent
r_test <- crop(r_rain, r)
r_test
plot(r_test)
plot(r)
plot(r_test)
r_test
r
dim(nc_dukems)
library(terra)
rspat_rain <- rast(nc_dukems_filename, varname = "RAINNC")
?rast
rspat_rain <- rast(nc_dukems_filename, names = "RAINNC")
rspat_rain <- rast(nc_dukems_filename, vals = "RAINNC")
plot(r_rain)
r_rain
r_test <- aggregate(r_rain, fact = 1000)
plot(r)
r_test <- aggregate(r_rain, fact = 10)
plot(r_test)
r_test
# Libraries----
library(ncdf4)
library(raster)
library(lubridate)
library(ggplot2)
library(sf)
library(terra)
# Files and directories----
nc_dukems_filename <- "C:\\Users\\thowag\\Documents\\dukems_nh3\\wrfout_d03_20180101-20190101_RAINNC_dy.nc"
nc_dukems <- nc_open(nc_dukems_filename)
# Dimensions check----
names(nc_dukems$dim)
# Time variable check
ncatt_get(nc_dukems, varid = "XTIME")
# Listing variables
names(nc_dukems$var)
# Checking rain variables
ncatt_get(nc_dukems, "RAINNC")
# Extracting single raster----
r_rain <- rast(nc_dukems_filename)
# Read in UK raster----
r_dauth <- rast("N:\\Useful_datasets\\dauth.asc")
# Take out the Isle of Man, which is labelled 4 in this raster
r_dauth[r_dauth == 4] <- NA
# Turn into UK reference raster
r <- setValues(r_dauth, 1:ncell(r_dauth))
# Set crs - proj4 deprecated for everything that isn't wgs84, so use EPSG codes
crs(r) <- "EPSG:27700"
crs(r_rain) <- "EPSG:3995" #epsg code for polar stereographic projection
r_test_terra <- terra::project(r_rain, r)
r_test_terra
plot(r_test_terra)
library(akima)
library(raster)
library(ncdf4)
library(data.table)
BNG <- CRS("+init=epsg:27700")
LL <- CRS("+init=epsg:4326")
nc_srce <- "C:\\Users\\thowag\\Documents\\dukems_nh3\\wrfout_d03_20180101-20190101_RAINNC_dy.nc"
nc <- nc_open(nc_srce)
nc
raster_uk_template <- raster(xmn=0, xmx=700000, ymn=0, ymx = 1300000, resolution = 1000, vals=NA, crs=BNG)
raster_uk_template
raster_uk_template <- rast(xmn=0, xmx=700000, ymn=0, ymx = 1300000, resolution = 1000, vals=NA, crs=BNG)
library(terra)
raster_uk_template <- rast(xmn=0, xmx=700000, ymn=0, ymx = 1300000, resolution = 1000, vals=NA, crs=BNG)
raster_uk_template
raster_uk_template <- raster(xmn=0, xmx=700000, ymn=0, ymx = 1300000, resolution = 1000, vals=NA, crs=BNG)
dt_emep <- data.table(lon = as.vector(ncvar_get(nc, "lon")), lat = as.vector(ncvar_get(nc, "lat")), data = as.vector(ncvar_get(nc,"SURF_ug_NH3")))
dt_emep <- data.table(lon = as.vector(ncvar_get(nc, "lon")), lat = as.vector(ncvar_get(nc, "lat")), data = as.vector(ncvar_get(nc,"RAINNC")))
# Variable and dimensions check----
names(nc_dukems$dim)
# Files and directories----
nc_dukems_filename <- "C:\\Users\\thowag\\Documents\\dukems_nh3\\wrfout_d03_20180101-20190101_RAINNC_dy.nc"
nc_dukems <- nc_open(nc_dukems_filename)
# Variable and dimensions check----
names(nc_dukems$dim)
ncatt_get(nc_dukems, varid = "XTIME")
names(nc_dukems$var)
dt_emep <- data.table(lon = as.vector(ncvar_get(nc, "XLONG")), lat = as.vector(ncvar_get(nc, "XLAT")), data = as.vector(ncvar_get(nc,"RAINNC")))
nc_close(nc)
dt_emep
dt_wrf <- data.table(lon = as.vector(ncvar_get(nc, "XLONG")), lat = as.vector(ncvar_get(nc, "XLAT")), data = as.vector(ncvar_get(nc,"RAINNC")))
nc <- nc_open(nc_srce)
raster_uk_template <- raster(xmn=0, xmx=700000, ymn=0, ymx = 1300000, resolution = 1000, vals=NA, crs=BNG)
dt_wrf <- data.table(lon = as.vector(ncvar_get(nc, "XLONG")), lat = as.vector(ncvar_get(nc, "XLAT")), data = as.vector(ncvar_get(nc,"RAINNC")))
nc_close(nc)
dt_wrf
# Variable and dimensions check----
names(nc_dukems$dim)
ncatt_get(nc_dukems, varid = "XTIME")
names(nc_dukems$var)
ncatt_get(nc_dukems, "RAINNC")
ncvar_get(nc_dukesm, varid = "XTIME")
ncvar_get(nc_dukems, varid = "XTIME")
dt_wrf <- data.table(lon = as.vector(ncvar_get(nc, "XLONG")), lat = as.vector(ncvar_get(nc, "XLAT")), data = as.vector(ncvar_get(nc,"RAINNC")))
nc_close(nc)
dt_wrf
## the options here are
##     to make the above dt into points and rasterize
##  OR to make the above into a regular grid on a higher res and rasterfromXYZ
# this is slow; interpolating 0.05 irregular data onto a regular grid (3 mins?)
# you could reduce the number of points probably
datint <- interp(x = dt_emep[,lon], y = dt_emep[,lat], z = dt_emep[,data],
xo = seq(min(dt_emep[,lon]), max(dt_emep[,lon]), length = ncol(raster_uk_template)*2),
yo = seq(min(dt_emep[,lat]), max(dt_emep[,lat]), length = nrow(raster_uk_template)*2),
linear=T)
library(akima)
install.packages("akima")
library(akima)
library(raster)
library(ncdf4)
library(data.table)
## the options here are
##     to make the above dt into points and rasterize
##  OR to make the above into a regular grid on a higher res and rasterfromXYZ
# this is slow; interpolating 0.05 irregular data onto a regular grid (3 mins?)
# you could reduce the number of points probably
datint <- interp(x = dt_emep[,lon], y = dt_emep[,lat], z = dt_emep[,data],
xo = seq(min(dt_emep[,lon]), max(dt_emep[,lon]), length = ncol(raster_uk_template)*2),
yo = seq(min(dt_emep[,lat]), max(dt_emep[,lat]), length = nrow(raster_uk_template)*2),
linear=T)
library(akima)
library(raster)
library(ncdf4)
library(data.table)
BNG <- CRS("+init=epsg:27700")
LL <- CRS("+init=epsg:4326")
nc_srce <- "C:\\Users\\thowag\\Documents\\dukems_nh3\\wrfout_d03_20180101-20190101_RAINNC_dy.nc"
nc <- nc_open(nc_srce)
raster_uk_template <- raster(xmn=0, xmx=700000, ymn=0, ymx = 1300000, resolution = 1000, vals=NA, crs=BNG)
dt_wrf <- data.table(lon = as.vector(ncvar_get(nc, "XLONG")), lat = as.vector(ncvar_get(nc, "XLAT")),
data = as.vector(ncvar_get(nc,"RAINNC")), time = as.vector(ncvar_get(nc, "XTIME")))
dt_wrf
nc_close(nc)
## the options here are
##     to make the above dt into points and rasterize
##  OR to make the above into a regular grid on a higher res and rasterfromXYZ
# this is slow; interpolating 0.05 irregular data onto a regular grid (3 mins?)
# you could reduce the number of points probably
datint <- interp(x = dt_emep[,lon], y = dt_emep[,lat], z = dt_emep[,data],
xo = seq(min(dt_emep[,lon]), max(dt_emep[,lon]), length = ncol(raster_uk_template)*2),
yo = seq(min(dt_emep[,lat]), max(dt_emep[,lat]), length = nrow(raster_uk_template)*2),
linear=T)
dt_wrf
## the options here are
##     to make the above dt into points and rasterize
##  OR to make the above into a regular grid on a higher res and rasterfromXYZ
# this is slow; interpolating 0.05 irregular data onto a regular grid (3 mins?)
# you could reduce the number of points probably
datint <- interp(x = dt_wrf[,lon], y = dt_wrf[,lat], z = dt_wrf[,data],
xo = seq(min(dt_wrf[,lon]), max(dt_wrf[,lon]), length = ncol(raster_uk_template)*2),
yo = seq(min(dt_wrf[,lat]), max(dt_wrf[,lat]), length = nrow(raster_uk_template)*2),
linear=T)
library(akima)
library(raster)
library(ncdf4)
library(data.table)
BNG <- CRS("+init=epsg:27700")
LL <- CRS("+init=epsg:4326")
nc_srce <- "C:\\Users\\thowag\\Documents\\dukems_nh3\\wrfout_d03_20180101-20190101_RAINNC_dy.nc"
nc <- nc_open(nc_srce)
raster_uk_template <- raster(xmn=0, xmx=700000, ymn=0, ymx = 1300000, resolution = 1000, vals=NA, crs=BNG)
dt_wrf <- data.table(lon = as.vector(ncvar_get(nc, "XLONG")), lat = as.vector(ncvar_get(nc, "XLAT")),
data = as.vector(ncvar_get(nc,"RAINNC")), time = as.vector(ncvar_get(nc, "XTIME")))
nc_close(nc)
## the options here are
##     to make the above dt into points and rasterize
##  OR to make the above into a regular grid on a higher res and rasterfromXYZ
# this is slow; interpolating 0.05 irregular data onto a regular grid (3 mins?)
# you could reduce the number of points probably
datint <- interp(x = dt_wrf[,lon], y = dt_wrf[,lat], z = dt_wrf[,data], time = dt_wrf[,time]
xo = seq(min(dt_wrf[,lon]), max(dt_wrf[,lon]), length = ncol(raster_uk_template)*2),
yo = seq(min(dt_wrf[,lat]), max(dt_wrf[,lat]), length = nrow(raster_uk_template)*2),
linear=T)
## the options here are
##     to make the above dt into points and rasterize
##  OR to make the above into a regular grid on a higher res and rasterfromXYZ
# this is slow; interpolating 0.05 irregular data onto a regular grid (3 mins?)
# you could reduce the number of points probably
datint <- interp(x = dt_wrf[,lon], y = dt_wrf[,lat], z = dt_wrf[,data], time = dt_wrf[,time],
xo = seq(min(dt_wrf[,lon]), max(dt_wrf[,lon]), length = ncol(raster_uk_template)*2),
yo = seq(min(dt_wrf[,lat]), max(dt_wrf[,lat]), length = nrow(raster_uk_template)*2),
linear=T)
?interp
shiny::runApp('met_db/R')
library(shiny)
library(shinydashboard)
library(shinyWidgets)
library(shinyjs)
library(shinythemes)
library(lubridate)
library(plyr)
library(dplyr)
library(ggplot2)
library(readr)
library(ggiraph)
library(ROracle)
library(readxl)
library(DT)
library(data.table)
library(mgcv)
library(shinyalert)
library(shiny)
library(shinydashboard)
library(shinyWidgets)
library(shinyjs)
library(shinythemes)
library(lubridate)
library(plyr)
library(dplyr)
library(ggplot2)
library(readr)
library(ggiraph)
library(ROracle)
library(readxl)
library(DT)
library(data.table)
library(mgcv)
library(shinyalert)
runApp('met_db/R')
library(shinydashboard)
install.packages("shinydashboard")
runApp('met_db/R')
library(shinydashboard)
library(shiny)
library(shinydashboard)
library(shinyWidgets)
library(shinyjs)
library(shinythemes)
library(lubridate)
library(plyr)
library(dplyr)
library(ggplot2)
library(readr)
library(ggiraph)
library(ROracle)
library(readxl)
library(DT)
library(data.table)
library(mgcv)
library(shinyalert)
runApp('met_db/R')
install.packages("shinyalert")
shiny::runApp('met_db/R')
library(shiny)
library(shinydashboard)
library(shinyWidgets)
library(shinyjs)
library(shinythemes)
library(lubridate)
library(plyr)
library(dplyr)
library(ggplot2)
library(readr)
library(ggiraph)
library(ROracle)
library(readxl)
library(DT)
library(data.table)
library(mgcv)
library(shinyalert)
runApp('met_db/R')
library(lubridate)
runApp('met_db/R')
df_qry
runApp('met_db/R')
runApp('met_db/R')
?fluidRow
runApp('met_db/R')
runApp('met_db/R')
?hidden()
runApp('met_db/R')
?fluidRow
?box
runApp('met_db/R')
?hidden
runApp('met_db/R')
?fluidPage
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
?toggle()
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
?box
?fluidRow
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
?column()
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
?tableOutput
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
?tabsetPanel
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
?hiddne
?hidden
?tagList
?div
?p()
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
?eventReactive
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
runApp('met_db/R')
?tableOutput
runApp('met_db/R')
?renderDataTable
runApp('met_db/R')
runApp('met_db/R')
# Reading in the data flags ----
data_flags <- read_csv("../data/data_flags.csv")
data_flags$code <- as.character(data_flags$code)
runApp('met_db/R')
df_qry
job_df
job_df()
shiny::runApp('met_db/R')
library(shinydashboard)
library(shinyWidgets)
library(shinyjs)
library(shinythemes)
library(lubridate)
library(plyr)
library(dplyr)
library(ggplot2)
library(readr)
library(ggiraph)
library(ROracle)
library(readxl)
library(DT)
library(data.table)
library(mgcv)
library(shinyalert)
library(shiny)
runApp('met_db/R')
